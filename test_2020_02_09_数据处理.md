
# 第五天——NumPy_3

## 4.3利用数组进行数据处理
用数组表达式代替循环称为矢量化。


```python
import numpy as np
```

### 利用NumPy对一组网格型数据计算sqrt(x^2+y^2)


```python
points = np.arange(-5,5,0.01)
xs,ys = np.meshgrid(points,points) #生成网格数据数组，xs与ys互为转置
```


```python
ys
```




    array([[-5.  , -5.  , -5.  , ..., -5.  , -5.  , -5.  ],
           [-4.99, -4.99, -4.99, ..., -4.99, -4.99, -4.99],
           [-4.98, -4.98, -4.98, ..., -4.98, -4.98, -4.98],
           ...,
           [ 4.97,  4.97,  4.97, ...,  4.97,  4.97,  4.97],
           [ 4.98,  4.98,  4.98, ...,  4.98,  4.98,  4.98],
           [ 4.99,  4.99,  4.99, ...,  4.99,  4.99,  4.99]])




```python
xs
```




    array([[-5.  , -4.99, -4.98, ...,  4.97,  4.98,  4.99],
           [-5.  , -4.99, -4.98, ...,  4.97,  4.98,  4.99],
           [-5.  , -4.99, -4.98, ...,  4.97,  4.98,  4.99],
           ...,
           [-5.  , -4.99, -4.98, ...,  4.97,  4.98,  4.99],
           [-5.  , -4.99, -4.98, ...,  4.97,  4.98,  4.99],
           [-5.  , -4.99, -4.98, ...,  4.97,  4.98,  4.99]])




```python
zs = np.sqrt(xs**2+ys**2)
zs.astype(np.dtype(np.float32))
```




    array([[7.071068 , 7.064    , 7.05694  , ..., 7.0498867, 7.05694  ,
            7.064    ],
           [7.064    , 7.056926 , 7.049858 , ..., 7.0427976, 7.049858 ,
            7.056926 ],
           [7.05694  , 7.049858 , 7.0427837, ..., 7.035716 , 7.0427837,
            7.049858 ],
           ...,
           [7.0498867, 7.0427976, 7.035716 , ..., 7.028641 , 7.035716 ,
            7.0427976],
           [7.05694  , 7.049858 , 7.0427837, ..., 7.035716 , 7.0427837,
            7.049858 ],
           [7.064    , 7.056926 , 7.049858 , ..., 7.0427976, 7.049858 ,
            7.056926 ]], dtype=float32)



### where函数
实现三元表达式if x condition else y（如果condition为真则执行x否则执行y）的矢量化


```python
tt = np.random.randn(20)
ts = np.zeros(20)
tp = tt>ts
tp
```




    array([ True, False, False, False, False, False, False, False,  True,
           False,  True,  True,  True, False,  True, False, False,  True,
            True, False])




```python
xarr = np.random.randn(20)*20
print(xarr)
yarr = np.random.randn(20)*20
print(yarr)
cond = tp
print(cond)
result = np.where(cond,xarr,yarr)
result
```

    [-20.42964736 -13.30634791  14.93632319  29.78370893  14.88205657
      29.28676865 -19.24746072  26.19620955 -13.12748317 -13.28869919
       5.83053532   7.10586664   3.30850042  -8.55414059   3.50484085
      12.70075292   7.11459679 -15.99759541  -1.38664794 -13.7150921 ]
    [  8.41331946  -4.19229242  18.40552846  20.37056983  -5.60020829
     -15.36001065  14.53770509  10.35137758  35.77497815   8.70305519
     -33.17349837  21.18709695  11.2455181  -13.25244063  16.82693938
     -20.16336442  25.29341236 -21.63810749  16.45803683  35.1429737 ]
    [ True False False False False False False False  True False  True  True
      True False  True False False  True  True False]
    




    array([-20.42964736,  -4.19229242,  18.40552846,  20.37056983,
            -5.60020829, -15.36001065,  14.53770509,  10.35137758,
           -13.12748317,   8.70305519,   5.83053532,   7.10586664,
             3.30850042, -13.25244063,   3.50484085, -20.16336442,
            25.29341236, -15.99759541,  -1.38664794,  35.1429737 ])



where函数的第二个和第三个参数也可以是标量


```python
cond1 = tp.reshape((4,5))
print(cond1)
```

    [[ True False False False False]
     [False False False  True False]
     [ True  True  True False  True]
     [False False  True  True False]]
    


```python
np.where(cond1,1,0)
```




    array([[1, 0, 0, 0, 0],
           [0, 0, 0, 1, 0],
           [1, 1, 1, 0, 1],
           [0, 0, 1, 1, 0]])




```python
yarr2 = np.random.randn(20).reshape((4,5))*20
np.where(cond1,2,yarr2)
```




    array([[  2.        ,  29.57567063,  -4.54495339,  14.25045429,
             30.81269903],
           [ 34.92415819, -10.59122965, -43.95013281,   2.        ,
             12.79805803],
           [  2.        ,   2.        ,   2.        ,   7.96876933,
              2.        ],
           [ -6.0838228 ,  12.51620666,   2.        ,   2.        ,
             -3.04303773]])



### 数学和统计方法

可以通过数组上的一组数学函数对整个数组或某个轴向的数组进行统计计算


```python
arr1 = np.arange(24).reshape(2,3,4)
arr1
```




    array([[[ 0,  1,  2,  3],
            [ 4,  5,  6,  7],
            [ 8,  9, 10, 11]],
    
           [[12, 13, 14, 15],
            [16, 17, 18, 19],
            [20, 21, 22, 23]]])




```python
arr1.sum(axis = 0) #对arr[0~(n-1)][x][y]求和
```




    array([[12, 14, 16, 18],
           [20, 22, 24, 26],
           [28, 30, 32, 34]])




```python
arr1.sum(axis = 1)#对arr[x][0~(n-1)][y]求和
```




    array([[12, 15, 18, 21],
           [48, 51, 54, 57]])




```python
arr1.sum(axis = 2)#对arr[x][y][0~(n-1)]求和
```




    array([[ 6, 22, 38],
           [54, 70, 86]])



可见对每一个轴进行sun,mean这类函数计算会聚合而减少一个维度


而累加函数(cumsum)会计算每一步的聚类返回一个同样大小的数组


```python
arr2 = np.array([[0,1,2],[3,4,5],[6,7,8]])
arr2
```




    array([[0, 1, 2],
           [3, 4, 5],
           [6, 7, 8]])




```python
arr2.cumsum(axis = 0)
```




    array([[ 0,  1,  2],
           [ 3,  5,  7],
           [ 9, 12, 15]], dtype=int32)



### 常用的数学统计方法

|方法|说明|
|-|-|
|sum|对数组全体或某轴求和，零长度求和为0|
|mean|同上求积，零长度为NaN|
|std\var|分别为标准差和方差，自由度可调（默认为n）|
|min\max|最大值\最小值|
|argmin\argmax|分别为最大元素和最小元素的索引|
|cumsum|所有元素的累计和|
|cumprod|所有元素的累计积|

### 用于布尔型数组的方法
在以上这些计算中布尔值会被转换为1和0。因此sum值经常被用来对布尔型数组中的true和false计数。


```python
arr3 = np.random.randn(100)
(arr3>0).sum()
```




    45



此外还有方法any和all，any计算数组中是否有一个或多个true，all用于计算数组中是否都是true，这两个方法也可用于非布尔型，非零都为true。

### 排序

NumPy可以和Python内置列表类型一样通过sort方法就地排序


```python
arr4 = np.array([5,2,3,2,1,6,1,6,3,7])
arr4.sort()
arr4
```




    array([1, 1, 2, 2, 3, 3, 5, 6, 6, 7])



多维数组可以通过把轴号传入sort来对某一轴排序


```python
arr5 = np.random.randn(4,4)
arr5
```




    array([[ 0.73638282,  0.76025463,  2.46852369, -0.52168609],
           [-0.15126712,  0.3959621 ,  1.43687116, -0.16775019],
           [-0.38821231, -0.85349468, -0.14713548, -1.36012167],
           [ 0.39966241,  0.39147319, -0.99621955, -0.19507691]])




```python
arr5.sort(1)
arr5
```




    array([[-0.52168609,  0.73638282,  0.76025463,  2.46852369],
           [-0.16775019, -0.15126712,  0.3959621 ,  1.43687116],
           [-1.36012167, -0.85349468, -0.38821231, -0.14713548],
           [-0.99621955, -0.19507691,  0.39147319,  0.39966241]])



顶级方法(np.sort())返回的是数组排序的副本，而就地排序(arr.sort())会改变数组本身


```python
arr6 = np.random.randn(4,4)
arr6
```




    array([[ 0.26665098, -0.65740553,  0.43401699, -1.27590528],
           [-0.75952924, -1.25469376,  1.72614571, -0.81118504],
           [-3.23679531, -0.53522629,  0.79646145,  0.27550811],
           [-0.45069826, -0.02455095,  0.71511524, -1.4224204 ]])




```python
np.sort(arr6)  #返回的是副本，arr6值未变
arr6
```




    array([[ 0.26665098, -0.65740553,  0.43401699, -1.27590528],
           [-0.75952924, -1.25469376,  1.72614571, -0.81118504],
           [-3.23679531, -0.53522629,  0.79646145,  0.27550811],
           [-0.45069826, -0.02455095,  0.71511524, -1.4224204 ]])




```python
arr6.sort()
arr6 #arr6值改变
```




    array([[-1.27590528, -0.65740553,  0.26665098,  0.43401699],
           [-1.25469376, -0.81118504, -0.75952924,  1.72614571],
           [-3.23679531, -0.53522629,  0.27550811,  0.79646145],
           [-1.4224204 , -0.45069826, -0.02455095,  0.71511524]])



## 唯一化及其他的集合逻辑

NumPy提供了一些针对一维ndarray的基本集合运算。

#### np.unique
它用于找出数组中的唯一值并返回已排序的结果：


```python
names = np.array(['Bob','Joe','Lion','Bob'])
np.unique(names)
```




    array(['Bob', 'Joe', 'Lion'], dtype='<U4')




```python
arr7 = np.array([5,2,3,2,1,6,1,6,3,7])
np.unique(arr7)
```




    array([1, 2, 3, 5, 6, 7])



其等价的Python代码为


```python
sorted(set(arr7))
```




    [1, 2, 3, 5, 6, 7]



### NumPy中的集合函数

|函数|说明|
|-|-|
|unique(x)|计算x中的唯一元素，并返回有序的结果|
|intersect1d(x,y)|计算x和y中的公共元素，并返回有序结果|
|union1d(x,y)|计算x和y的并集，并返回有序结果|
|in1d(x,y)|得到一个表示‘x的元素是否包含于y’的布尔型数组|
|setdiff1d(x,y)|集合的差，即元素在x中但不在y中|
|setxor1d(x,y)|集合的对称差，即元素不同时存在于x和y|

## 4.4用于数组的文件输入输出
（暂时不看）
